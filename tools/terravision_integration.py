"""TerraVision Integration for Enhanced HCL Parsing and Analysis."""

import os
import json
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass


@dataclass
class TerraVisionConfig:
    """Configuration for TerraVision integration."""
    mock_aws_access_key: str = "mock_access_key"
    mock_aws_secret_key: str = "mock_secret_key"
    mock_aws_region: str = "us-east-1"
    mock_azure_subscription_id: str = "mock_subscription_id"
    mock_azure_client_id: str = "mock_client_id"
    mock_azure_client_secret: str = "mock_client_secret"
    mock_azure_tenant_id: str = "mock_tenant_id"
    mock_gcp_project_id: str = "mock_project_id"
    mock_gcp_credentials: str = "mock_credentials.json"
    mock_oci_user_id: str = "mock_user_id"
    mock_oci_fingerprint: str = "mock_fingerprint"
    mock_oci_private_key: str = "mock_private_key"
    mock_oci_tenancy: str = "mock_tenancy"
    mock_ibm_api_key: str = "mock_api_key"
    mock_ibm_resource_group: str = "mock_resource_group"
    skip_credentials_validation: bool = True
    skip_requesting_account_id: bool = True
    skip_metadata_api_check: bool = True
    auto_generate_mock_providers: bool = True
    mock_provider_file_suffix: str = "_generated_providers.tf"


class TerraVisionAnalyzer:
    """Enhanced HCL analysis using TerraVision capabilities."""
    
    def __init__(self, config: Optional[TerraVisionConfig] = None):
        self.config = config or TerraVisionConfig()
        self.temp_dir = None
    
    def _setup_mock_environment(self) -> Dict[str, str]:
        """Setup comprehensive mock environment for TerraVision."""
        env = {
            # AWS Mock Environment
            "AWS_ACCESS_KEY_ID": self.config.mock_aws_access_key,
            "AWS_SECRET_ACCESS_KEY": self.config.mock_aws_secret_key,
            "AWS_DEFAULT_REGION": self.config.mock_aws_region,
            "TF_VAR_access_key": self.config.mock_aws_access_key,
            "TF_VAR_secret_key": self.config.mock_aws_secret_key,
            "TF_VAR_region": self.config.mock_aws_region,
            
            # Azure Mock Environment
            "ARM_SUBSCRIPTION_ID": self.config.mock_azure_subscription_id,
            "ARM_CLIENT_ID": self.config.mock_azure_client_id,
            "ARM_CLIENT_SECRET": self.config.mock_azure_client_secret,
            "ARM_TENANT_ID": self.config.mock_azure_tenant_id,
            "TF_VAR_subscription_id": self.config.mock_azure_subscription_id,
            "TF_VAR_client_id": self.config.mock_azure_client_id,
            "TF_VAR_client_secret": self.config.mock_azure_client_secret,
            "TF_VAR_tenant_id": self.config.mock_azure_tenant_id,
            
            # GCP Mock Environment
            "GOOGLE_PROJECT_ID": self.config.mock_gcp_project_id,
            "GOOGLE_APPLICATION_CREDENTIALS": self.config.mock_gcp_credentials,
            "TF_VAR_project_id": self.config.mock_gcp_project_id,
            "TF_VAR_credentials": self.config.mock_gcp_credentials,
            
            # OCI Mock Environment
            "OCI_USER_ID": self.config.mock_oci_user_id,
            "OCI_FINGERPRINT": self.config.mock_oci_fingerprint,
            "OCI_PRIVATE_KEY": self.config.mock_oci_private_key,
            "OCI_TENANCY": self.config.mock_oci_tenancy,
            "TF_VAR_user_id": self.config.mock_oci_user_id,
            "TF_VAR_fingerprint": self.config.mock_oci_fingerprint,
            "TF_VAR_private_key": self.config.mock_oci_private_key,
            "TF_VAR_tenancy": self.config.mock_oci_tenancy,
            
            # IBM Mock Environment
            "IBMCLOUD_API_KEY": self.config.mock_ibm_api_key,
            "IC_API_KEY": self.config.mock_ibm_api_key,
            "TF_VAR_api_key": self.config.mock_ibm_api_key,
            "TF_VAR_resource_group": self.config.mock_ibm_resource_group,
            
            # Terraform Skip Flags
            "TF_SKIP_CREDENTIAL_VALIDATION": "true",
            "TF_SKIP_METADATA_CHECK": "true",
            "CHECKPOINT_DISABLE": "true",
        }
        return env
    
    def _generate_mock_provider_config(self, terraform_dir: Path) -> None:
        """Generate comprehensive mock provider configuration for TerraVision."""
        provider_config = f"""# Auto-generated mock providers for TerraVision analysis
# Generated by auto-arch-diagram TerraVision integration
# This file provides mock credentials to prevent Terraform from making real API calls

provider "aws" {{
  region                      = "{self.config.mock_aws_region}"
  access_key                  = "{self.config.mock_aws_access_key}"
  secret_key                  = "{self.config.mock_aws_secret_key}"
  skip_credentials_validation = {str(self.config.skip_credentials_validation).lower()}
  skip_requesting_account_id  = {str(self.config.skip_requesting_account_id).lower()}
  skip_metadata_api_check     = {str(self.config.skip_metadata_api_check).lower()}
}}

provider "azurerm" {{
  subscription_id             = "{self.config.mock_azure_subscription_id}"
  client_id                  = "{self.config.mock_azure_client_id}"
  client_secret              = "{self.config.mock_azure_client_secret}"
  tenant_id                  = "{self.config.mock_azure_tenant_id}"
  skip_provider_registration = true
}}

provider "google" {{
  project     = "{self.config.mock_gcp_project_id}"
  credentials = "{self.config.mock_gcp_credentials}"
  region      = "{self.config.mock_aws_region}"
}}

provider "oci" {{
  user_id        = "{self.config.mock_oci_user_id}"
  fingerprint    = "{self.config.mock_oci_fingerprint}"
  private_key    = "{self.config.mock_oci_private_key}"
  tenancy        = "{self.config.mock_oci_tenancy}"
  region         = "{self.config.mock_aws_region}"
  skip_credentials_validation = true
}}

provider "ibm" {{
  region           = "{self.config.mock_aws_region}"
  ibmcloud_api_key = "{self.config.mock_ibm_api_key}"
  resource_group   = "{self.config.mock_ibm_resource_group}"
}}

# Terraform settings for enhanced mock analysis
terraform {{
  required_providers {{
    aws = {{
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }}
    azurerm = {{
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }}
    google = {{
      source  = "hashicorp/google"
      version = "~> 4.0"
    }}
    oci = {{
      source  = "oracle/oci"
      version = "~> 4.0"
    }}
    ibm = {{
      source  = "IBM-Cloud/ibm"
      version = "~> 1.0"
    }}
  }}
}}
"""
        
        # Write to temporary provider file
        provider_file = terraform_dir / self.config.mock_provider_file_suffix
        provider_file.write_text(provider_config)
        
        # Also generate a .terraformrc file for additional mock settings
        terraformrc_content = f"""# Terraform configuration for enhanced mock analysis
provider_installation {{
  filesystem_mirror = "{terraform_dir}/.terraform/providers"
}}
"""
        terraformrc_file = terraform_dir / ".terraformrc"
        terraformrc_file.write_text(terraformrc_content)
    
    def analyze_with_terravision(self, terraform_dir: Path) -> Dict[str, Any]:
        """
        Analyze Terraform files using TerraVision Docker container.
        
        Args:
            terraform_dir: Directory containing Terraform files
            
        Returns:
            Dictionary containing parsed resources, dependencies, and metadata
        """
        try:
            # Create temporary directory for analysis
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)
                
                # Copy terraform files to temp directory
                import shutil
                for tf_file in terraform_dir.glob("*.tf"):
                    shutil.copy2(tf_file, temp_path / tf_file.name)
                
                # Add mock provider configuration
                self._generate_mock_provider_config(temp_path)
                
                # Setup mock environment
                env = os.environ.copy()
                env.update(self._setup_mock_environment())
                
                # Run TerraVision Docker container with comprehensive mock environment
                cmd = [
                    "docker", "run", "--rm",
                    "-v", f"{temp_path}:/project",
                    "-e", f"AWS_ACCESS_KEY_ID={self.config.mock_aws_access_key}",
                    "-e", f"AWS_SECRET_ACCESS_KEY={self.config.mock_aws_secret_key}",
                    "-e", f"AWS_DEFAULT_REGION={self.config.mock_aws_region}",
                    "-e", f"TF_VAR_access_key={self.config.mock_aws_access_key}",
                    "-e", f"TF_VAR_secret_key={self.config.mock_aws_secret_key}",
                    "-e", f"TF_VAR_region={self.config.mock_aws_region}",
                    "-e", f"ARM_SUBSCRIPTION_ID={self.config.mock_azure_subscription_id}",
                    "-e", f"ARM_CLIENT_ID={self.config.mock_azure_client_id}",
                    "-e", f"ARM_CLIENT_SECRET={self.config.mock_azure_client_secret}",
                    "-e", f"ARM_TENANT_ID={self.config.mock_azure_tenant_id}",
                    "-e", f"TF_VAR_subscription_id={self.config.mock_azure_subscription_id}",
                    "-e", f"TF_VAR_client_id={self.config.mock_azure_client_id}",
                    "-e", f"TF_VAR_client_secret={self.config.mock_azure_client_secret}",
                    "-e", f"TF_VAR_tenant_id={self.config.mock_azure_tenant_id}",
                    "-e", f"GOOGLE_PROJECT_ID={self.config.mock_gcp_project_id}",
                    "-e", f"GOOGLE_APPLICATION_CREDENTIALS={self.config.mock_gcp_credentials}",
                    "-e", f"TF_VAR_project_id={self.config.mock_gcp_project_id}",
                    "-e", f"TF_VAR_credentials={self.config.mock_gcp_credentials}",
                    "-e", f"OCI_USER_ID={self.config.mock_oci_user_id}",
                    "-e", f"OCI_FINGERPRINT={self.config.mock_oci_fingerprint}",
                    "-e", f"OCI_PRIVATE_KEY={self.config.mock_oci_private_key}",
                    "-e", f"OCI_TENANCY={self.config.mock_oci_tenancy}",
                    "-e", f"TF_VAR_user_id={self.config.mock_oci_user_id}",
                    "-e", f"TF_VAR_fingerprint={self.config.mock_oci_fingerprint}",
                    "-e", f"TF_VAR_private_key={self.config.mock_oci_private_key}",
                    "-e", f"TF_VAR_tenancy={self.config.mock_oci_tenancy}",
                    "-e", f"IBMCLOUD_API_KEY={self.config.mock_ibm_api_key}",
                    "-e", f"IC_API_KEY={self.config.mock_ibm_api_key}",
                    "-e", f"TF_VAR_api_key={self.config.mock_ibm_api_key}",
                    "-e", f"TF_VAR_resource_group={self.config.mock_ibm_resource_group}",
                    "-e", "TF_SKIP_CREDENTIAL_VALIDATION=true",
                    "-e", "TF_SKIP_METADATA_CHECK=true",
                    "-e", "CHECKPOINT_DISABLE=true",
                    "patrickchugh/terravision",
                    "draw",
                    "--source", "/project",
                    "--format", "json",
                    "--outfile", "/project/analysis.json"
                ]
                
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    env=env,
                    timeout=300  # 5 minute timeout
                )
                
                if result.returncode != 0:
                    print(f"TerraVision error: {result.stderr}")
                    return self._fallback_analysis(terraform_dir)
                
                # Read analysis results
                analysis_file = temp_path / "analysis.json"
                if analysis_file.exists():
                    analysis = json.loads(analysis_file.read_text())
                    return self._process_terravision_analysis(analysis)
                else:
                    return self._fallback_analysis(terraform_dir)
                    
        except Exception as e:
            print(f"TerraVision analysis failed: {e}")
            return self._fallback_analysis(terraform_dir)
    
    def _process_terravision_analysis(self, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Process TerraVision analysis into our format."""
        processed = {
            "resources": {},
            "dependencies": [],
            "metadata": {
                "source": "terravision",
                "complexity_score": 0,
                "cloud_providers": set(),
                "resource_types": set()
            }
        }
        
        # Extract resources from TerraVision output
        if "resources" in analysis:
            for resource in analysis["resources"]:
                res_name = resource.get("name", "unknown")
                res_type = resource.get("type", "unknown")
                res_config = resource.get("config", {})
                
                processed["resources"][res_name] = {
                    "type": res_type,
                    "config": res_config,
                    "provider": self._extract_provider_from_type(res_type),
                    "dependencies": resource.get("dependencies", [])
                }
                
                # Track metadata
                processed["metadata"]["resource_types"].add(res_type)
                provider = self._extract_provider_from_type(res_type)
                if provider:
                    processed["metadata"]["cloud_providers"].add(provider)
        
        # Extract dependencies
        if "dependencies" in analysis:
            for dep in analysis["dependencies"]:
                source = dep.get("source")
                target = dep.get("target")
                if source and target:
                    processed["dependencies"].append((source, target))
        
        # Calculate complexity score
        processed["metadata"]["complexity_score"] = self._calculate_complexity(
            len(processed["resources"]),
            len(processed["dependencies"]),
            len(processed["metadata"]["cloud_providers"])
        )
        
        # Convert sets to lists for JSON serialization
        processed["metadata"]["cloud_providers"] = list(processed["metadata"]["cloud_providers"])
        processed["metadata"]["resource_types"] = list(processed["metadata"]["resource_types"])
        
        return processed
    
    def _extract_provider_from_type(self, resource_type: str) -> Optional[str]:
        """Extract cloud provider from resource type."""
        if resource_type.startswith("aws_"):
            return "aws"
        elif resource_type.startswith("azurerm_"):
            return "azure"
        elif resource_type.startswith("google_"):
            return "gcp"
        elif resource_type.startswith("oci_"):
            return "oci"
        elif resource_type.startswith("ibm_"):
            return "ibm"
        return None
    
    def _calculate_complexity(self, resource_count: int, dependency_count: int, provider_count: int) -> int:
        """Calculate complexity score for the architecture."""
        # Simple complexity algorithm
        base_score = resource_count * 1
        dependency_score = dependency_count * 2
        provider_score = provider_count * 5
        return base_score + dependency_score + provider_score
    
    def _fallback_analysis(self, terraform_dir: Path) -> Dict[str, Any]:
        """Fallback to basic HCL parsing if TerraVision fails."""
        try:
            # Use existing hcl2 parsing as fallback
            import hcl2
            
            resources = {}
            dependencies = []
            providers = set()
            resource_types = set()
            
            for tf_file in terraform_dir.glob("*.tf"):
                content = tf_file.read_text()
                try:
                    parsed = hcl2.loads(content)
                    
                    # Extract resources
                    if "resource" in parsed:
                        for resource_type, resource_configs in parsed["resource"].items():
                            for resource_name, resource_config in resource_configs.items():
                                full_name = f"{resource_type}.{resource_name}"
                                resources[full_name] = {
                                    "type": resource_type,
                                    "config": resource_config,
                                    "provider": self._extract_provider_from_type(resource_type)
                                }
                                
                                resource_types.add(resource_type)
                                provider = self._extract_provider_from_type(resource_type)
                                if provider:
                                    providers.add(provider)
                                    
                except Exception:
                    continue
            
            return {
                "resources": resources,
                "dependencies": dependencies,
                "metadata": {
                    "source": "hcl2_fallback",
                    "complexity_score": self._calculate_complexity(len(resources), len(dependencies), len(providers)),
                    "cloud_providers": list(providers),
                    "resource_types": list(resource_types)
                }
            }
            
        except Exception as e:
            print(f"Fallback analysis failed: {e}")
            return {
                "resources": {},
                "dependencies": [],
                "metadata": {
                    "source": "error",
                    "complexity_score": 0,
                    "cloud_providers": [],
                    "resource_types": [],
                    "error": str(e)
                }
            }


def integrate_terravision_analysis(terraform_dir: Path, config: Optional[TerraVisionConfig] = None) -> Dict[str, Any]:
    """
    Integration function to use TerraVision for enhanced analysis.
    
    Args:
        terraform_dir: Directory containing Terraform files
        config: Optional TerraVision configuration
        
    Returns:
        Enhanced analysis results
    """
    analyzer = TerraVisionAnalyzer(config)
    return analyzer.analyze_with_terravision(terraform_dir)


# Example usage and integration points
def enhance_existing_workflow(terraform_dir: Path) -> Dict[str, Any]:
    """
    Example of how to integrate TerraVision into existing workflow.
    This can be called from generate_arch_diagram.py
    """
    # Configure TerraVision with mock credentials
    config = TerraVisionConfig(
        mock_aws_access_key="mock_access_key",
        mock_aws_secret_key="mock_secret_key",
        mock_aws_region="us-east-1"
    )
    
    # Get enhanced analysis
    analysis = integrate_terravision_analysis(terraform_dir, config)
    
    # Use analysis for better diagram generation
    resources = analysis.get("resources", {})
    dependencies = analysis.get("dependencies", [])
    metadata = analysis.get("metadata", {})
    
    print(f"üîç TerraVision Analysis Complete:")
    print(f"   Resources: {len(resources)}")
    print(f"   Dependencies: {len(dependencies)}")
    print(f"   Providers: {', '.join(metadata.get('cloud_providers', []))}")
    print(f"   Complexity Score: {metadata.get('complexity_score', 0)}")
    print(f"   Analysis Source: {metadata.get('source', 'unknown')}")
    
    return analysis
